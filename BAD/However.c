#pragma config(Sensor, S1,     Touch,          sensorEV3_Touch)
#pragma config(Sensor, S2,     Gyro,           sensorEV3_Gyro)
#pragma config(Sensor, S3,     Ultrasonic,     sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     Colour,         sensorEV3_Color)
#pragma config(Motor,  motorB,          LeftM,         tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          RightM,        tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{
	/*
			//Constants
	Cerror = 0;
	Cderivative = 0;
	Ccorrection = 0;
	CcorrectionP = 0;
	CcorrectionD = 0;
	while(true){
	Cerror = Cmidpoint - getColorReflected(Colour);
	Cderivative = Cerror - ClastError;
	Cintegral = Cintegral + Cerror;
	CcorrectionP = CkP*Cerror;
	CcorrectionI = CkI*Cintegral;
	CcorrectionD = CkD*Cderivative;
	Ccorrection = round(CcorrectionP + CcorrectionI +CcorrectionD);
	setMotorSpeed(LeftM, CnMotorSpeed+Ccorrection);
	setMotorSpeed(RightM, CnMotorSpeed-Ccorrection);
	ClastError = Cerror;
	delay(1);
		}

			//Line follower
	startTask(gyroReset);
	int CnMotorSpeed = 10;
	float CkP   = 10;
	float CkI = 0.0;
	float CkD = 0.0;
	float ClastError = 0;
	int Cmidpoint = 7;
	float Cerror = 0;
	float Cderivative = 0;
	float Cintegral = 0;
	float Ccorrection = 0;
	float CcorrectionP = 0;
	float CcorrectionI = 0;
	float CcorrectionD = 0;
	while(true){
	Cerror = Cmidpoint - getColorReflected(Colour);
	Cderivative = Cerror - ClastError;
	Cintegral = Cintegral + Cerror;
	CcorrectionP = CkP*Cerror;
	CcorrectionI = CkI*Cintegral;
	CcorrectionD = CkD*Cderivative;
	Ccorrection = round(CcorrectionP + CcorrectionI +CcorrectionD);
	setMotorSpeed(LeftM, CnMotorSpeed+Ccorrection);
	setMotorSpeed(RightM, CnMotorSpeed-Ccorrection);
	ClastError = Cerror;
	//datalogging
	datalogAddValue(0, getGyroDegrees(Gyro));
	//continue
	if(abs(getGyroDegrees(Gyro)) > 7){
	setMotorSpeed(RightM, 50);
	setMotorSpeed(LeftM, 50);
	wait1Msec(2000);
	break;
	}
	}
	*/


		//Maze solver
	setMotorBrakeMode(LeftM,motorBrake);
  setMotorBrakeMode(RightM,motorBrake);
	//Constants
	int nSpeed = 85;
	int nSpeedTurn = -85;
	int nSpeedTurnNeg = 85;
	float USD = 0.0;
	int TurnMs = 293;
	int OneCellMs = 1200;


while(true)
		{
		//If the button on
		if (getTouchValue(Touch))
			{
		//Vyrovnat se 100ms
			setMotorSpeed(LeftM, 100);
			setMotorSpeed(RightM, 100);
			wait1Msec(100);

			//Couvnout 250 ms
			setMotorSpeed(RightM, nSpeedTurn);
			setMotorSpeed(LeftM, nSpeedTurn);
			wait1Msec(250);
		//Zjistit zda je misto vlevo using Ultrasonic
			USD = getUSDistance(Ultrasonic);

		//Otocit vpravo je-li vzdalenost mensi, nez 20 cm
			if(USD < 26.0){
				setMotorSpeed(RightM, nSpeedTurn);
				setMotorSpeed(LeftM, nSpeedTurnNeg);
				wait1Msec(TurnMs);
			}

			else
				{
		//Otocit vlevo je-li vlevo misto
				setMotorSpeed(RightM, nSpeedTurnNeg);
				setMotorSpeed(LeftM, nSpeedTurn);
				wait1Msec(TurnMs);
		//Jet takhle 1 ctverec
				setMotorSpeed(RightM, nSpeed);
				setMotorSpeed(LeftM, nSpeed);
				wait1Msec(OneCellMs);
				}
		}


	//Neni-li tlacitko zmackle, merime vzdalenost Ultrasonikem
		USD = getUSDistance(Ultrasonic);

		//Je-li vzdalenost mensi nez 4-trochu tocime doprava a pak se vyrovnavame
		if(USD < 4.0)
			{
			//vyravnivanie
      setMotorSpeed(RightM, 0);
			setMotorSpeed(LeftM, 85);
			wait1Msec(25);
			setMotorSpeed(RightM, 85);
			setMotorSpeed(LeftM, 0);
			wait1Msec(19.7);
			}

		//Je-li vzdalenost mezi 4 az 8, jedeme rovne
		if(USD > 4.0 && USD < 8.0)
			{
			//jed rovne
			setMotorSpeed(RightM, nSpeed);
			setMotorSpeed(LeftM, nSpeed);
			wait1Msec(20);
			}

		//Je-li vzdalenost mezi 8 za 26 tocime doleva a pak se vyrovnavame
		if(USD > 8.0 && USD < 26.0)
			{
			//vyravnivanie
			setMotorSpeed(RightM, 85);
			setMotorSpeed(LeftM, 0);
			wait1Msec(25);
			setMotorSpeed(RightM, 0);
			setMotorSpeed(LeftM, 85);
			wait1Msec(18);
			}

	//Je-li vzdalenost vetsi nez 26, tocime doleva 90 stupnu
		if(USD > 26.0)
			{
			//Projed jeste trosicku rovne
		  setMotorSpeed(RightM, nSpeed);
			setMotorSpeed(LeftM, nSpeed);
			wait1Msec(20);
			//Toc doleva 90 stupnu
			setMotorSpeed(RightM, nSpeedTurnNeg);
			setMotorSpeed(LeftM, nSpeedTurn);
			wait1Msec(TurnMs);
			//Projed jeden cetverec
			setMotorSpeed(RightM, nSpeed);
			setMotorSpeed(LeftM, nSpeed);
			wait1Msec(OneCellMs);
			}
		}
	}
